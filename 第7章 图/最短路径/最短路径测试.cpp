
//**************************引入头文件*****************************
#include <stdio.h>   //使用了标准库函数 
#include <stdlib.h>  //使用了动态内存分配函数

#include "my_constants.h" //引入自定义的符号常量，主要是状态码 
#include "MGraph.h"       //引入图的邻接矩阵表示法的基本定义 
#include "MGraph.cpp"     //引入图的主要操作
#include "ShortestPath.cpp" //引入图的最短路径算法实现 


//----------------------主函数----------------------
int main(int argc, char *argv[]){
    
	printf("\n-------------基于邻接矩阵的最短路径算法测试程序--------------\n\n"); 
	
	//图G 
	MGraph G; 
	
	//临时变量，保存输入的顶点 
	VertexType v1, v2;
	
	//临时变量，保存输入的顶点数 
	int n;
	
	//图的创建
	printf("->测试图的创建：（最短路径算法要求图必须是有向网，请选择1）\n");
	CreateGraph(G);
	
	//打印邻接矩阵
	printf("\n->创建成功后图的邻接矩阵:\n\n"); 
	PrintAdjMatrix(G);
	
	//测试最短路径 
	if(G.kind == DN){
	
		//迪杰斯特拉算法用到的临时变量： 
		int v0 = 0;       //源点
		PathMatrix P;     //P数组 
		ShortPathTable D; //D数组 
	
	    printf("\n->测试求有向网的最短路径：\n\n");
	    
	    //测试迪杰斯特拉算法 
		printf("->使用迪杰斯特拉算法求单源最短路径：\n"); 
	    ShortestPath_DIJ(G, v0, P, D);
	    
	    //打印迪杰斯特拉算法用的P数组 
	    printf("->迪杰斯特拉算法用到的最短路径数组P[i][j]如下(T表示TRUE，F表示FALSE)：\n");
	    for(int i = 0; i < G.vexnum; ++i) {
	    	for(int j = 0; j < G.vexnum; ++j) { 
	    	    printf(" %3c ", P[i][j] == 1 ? 'T' : 'F');
	    	}//for 
	    	printf("\n");
	    }//for
	    
	    //打印迪杰斯特拉算法用的D数组 
	    printf("顶点%d到其他顶点的最短路径如下：\n", v0);
	    for(int i = 0; i < G.vexnum; ++i) { 
	        printf("%d ---> %d ：%3d\n", v0, G.vexs[i], D[i]);
		}//for
		
		//弗洛伊德算法用到的两个数组 
		//这两个数组和迪斯特拉算法的两个数组虽然同名但没有关系 
		PathMatrix1 P1;    //P数组 
		DistanceMatrix D1; //D数组 
		
		//测试弗洛伊德算法 
	    printf("->使用弗洛伊德算法求任意两顶点最短路径：\n");
	    //ShortestPath_FLOYD()要求对角线元素为0 
	    for(int i = 0; i < G.vexnum; ++i) { 
	        G.arcs[i][i].adj = 0;
	    }//for
		 
	    printf("->执行算法前的邻接矩阵如下：\n");
	    PrintAdjMatrix(G);
	    
	    //执行弗洛伊德算法 
	    ShortestPath_FLOYD(G, P1, D1);
	    
	    //打印弗洛伊德算法用的D数组 
	    printf("->弗洛伊德算法用的D数组：\n\n");
	    
	    //输出左上角多余的空白 
		printf("      ");
		
		//输出邻接矩阵的上坐标（全部顶点） 
		for(int i = 0; i < G.vexnum; i++) {
			
			printf(" %3d ", i); 	
		}//for 
		
		printf("\n"); 
		
		//输出左上角多余的空白 
		printf("     +");
		
		//输出一条横线
		for(int i = 0; i < G.vexnum; i++) {
			printf("-----"); 
		}//for 
		
		printf("\n"); 
	    
		for(int i = 0; i < G.vexnum; ++i) {
			
			//输出邻接矩阵左边的坐标
			printf(" %3d |", G.vexs[i]);  
			
			for(int j = 0; j < G.vexnum; ++j) {
				if(D1[i][j] == INFINITY) {
				   printf("  ∞ ");
				}//if 
				else {
				   printf(" %3d ", D1[i][j]);
				}//else 
			}//for   
	    	printf("\n     |\n");
		}//for
		
		//打印计算得到的最短路径 
		printf("\n->最短路径的计算结果：\n");
	    for(int i = 0; i < G.vexnum; ++i) { 
	    	for(int j = 0; j < G.vexnum; ++j) { 
	        	printf(" %d--->%d ：%-6d ", G.vexs[i], G.vexs[j], D1[i][j]);
			}//for
			printf("\n"); 
		}//for
		
		//打印弗洛伊德算法用的P数组 
	    printf("\n->弗洛伊德算法用的最短路径数组P[i][j][k]如下(T表示TRUE，F表示FALSE)：\n");
	    for(int i = 0; i < G.vexnum; ++i) {
	    	for(int j = 0; j < G.vexnum; ++j) {
	    	    for(int k = 0; k < G.vexnum; ++k){
	    	        printf("P[%d][%d][%d] = %c  ", i, j, k, P1[i][j][k] == 1 ? 'T' : 'F');
    	        }//for
    	        printf("\n");
    		}//for
		}//for 
	}//if 
    
    //测试销毁 
    printf("\n->测试销毁图： ");
	DestroyGraph(G); 
	printf("成功！\n");
	
	printf("演示结束，程序退出！\n");
	
	return 0;
} 

/*--------------------------输入全程记录（便于测试，可直接复制）------------------------------ 

   说明：有向网使用书上P188页的图7.34，可以直接去该页寻找最短路径的正确结果，以便于验证算法正确与否 



-------------基于邻接矩阵的最短路径算法测试程序--------------

->测试图的创建：（最短路径算法要求图必须是有向网，请选择1）
请输入您想构造的图的类型:有向图输入0,有向网输入1,无向图输入2,无向网输入3):1
请依次输入有向网G的顶点数，弧数，用逗号隔开
6,8
请依次输入有向网G的顶点名称，用空格隔开
0 1 2 3 4 5
请依次输入有向网G每条弧依附的两顶点名称及权值，输完一组按回车
0 5 100
0 4 30
0 2 10
1 2 5
2 3 50
4 3 20
4 5 60
3 5 10

->创建成功后图的邻接矩阵:

         0    1    2    3    4    5
     +------------------------------
   0 |  ∞   ∞   10   ∞   30  100
     |
   1 |  ∞   ∞    5   ∞   ∞   ∞
     |
   2 |  ∞   ∞   ∞   50   ∞   ∞
     |
   3 |  ∞   ∞   ∞   ∞   ∞   10
     |
   4 |  ∞   ∞   ∞   20   ∞   60
     |
   5 |  ∞   ∞   ∞   ∞   ∞   ∞
     |

->测试求有向网的最短路径：

->使用迪杰斯特拉算法求单源最短路径：
->迪杰斯特拉算法用到的最短路径数组P[i][j]如下(T表示TRUE，F表示FALSE)：
   F    F    F    F    F    F
   F    F    F    F    F    F
   T    F    T    F    F    F
   T    F    F    T    T    F
   T    F    F    F    T    F
   T    F    F    T    T    T
顶点0到其他顶点的最短路径如下：
0 ---> 0 ：  0
0 ---> 1 ：65535
0 ---> 2 ： 10
0 ---> 3 ： 50
0 ---> 4 ： 30
0 ---> 5 ： 60
->使用弗洛伊德算法求任意两顶点最短路径：
->执行算法前的邻接矩阵如下：
         0    1    2    3    4    5
     +------------------------------
   0 |   0   ∞   10   ∞   30  100
     |
   1 |  ∞    0    5   ∞   ∞   ∞
     |
   2 |  ∞   ∞    0   50   ∞   ∞
     |
   3 |  ∞   ∞   ∞    0   ∞   10
     |
   4 |  ∞   ∞   ∞   20    0   60
     |
   5 |  ∞   ∞   ∞   ∞   ∞    0
     |
->弗洛伊德算法用的D数组：

         0    1    2    3    4    5
     +------------------------------
   0 |   0   ∞   10   50   30   60
     |
   1 |  ∞    0    5   55   ∞   65
     |
   2 |  ∞   ∞    0   50   ∞   60
     |
   3 |  ∞   ∞   ∞    0   ∞   10
     |
   4 |  ∞   ∞   ∞   20    0   30
     |
   5 |  ∞   ∞   ∞   ∞   ∞    0
     |

->最短路径的计算结果：
 0--->0 ：0       0--->1 ：65535   0--->2 ：10      0--->3 ：50      0--->4 ：30      0--->5 ：60
 1--->0 ：65535   1--->1 ：0       1--->2 ：5       1--->3 ：55      1--->4 ：65535   1--->5 ：65
 2--->0 ：65535   2--->1 ：65535   2--->2 ：0       2--->3 ：50      2--->4 ：65535   2--->5 ：60
 3--->0 ：65535   3--->1 ：65535   3--->2 ：65535   3--->3 ：0       3--->4 ：65535   3--->5 ：10
 4--->0 ：65535   4--->1 ：65535   4--->2 ：65535   4--->3 ：20      4--->4 ：0       4--->5 ：30
 5--->0 ：65535   5--->1 ：65535   5--->2 ：65535   5--->3 ：65535   5--->4 ：65535   5--->5 ：0

->弗洛伊德算法用的最短路径数组P[i][j][k]如下(T表示TRUE，F表示FALSE)：
P[0][0][0] = T  P[0][0][1] = F  P[0][0][2] = F  P[0][0][3] = F  P[0][0][4] = F  P[0][0][5] = F
P[0][1][0] = F  P[0][1][1] = F  P[0][1][2] = F  P[0][1][3] = F  P[0][1][4] = F  P[0][1][5] = F
P[0][2][0] = T  P[0][2][1] = F  P[0][2][2] = T  P[0][2][3] = F  P[0][2][4] = F  P[0][2][5] = F
P[0][3][0] = T  P[0][3][1] = F  P[0][3][2] = F  P[0][3][3] = T  P[0][3][4] = T  P[0][3][5] = F
P[0][4][0] = T  P[0][4][1] = F  P[0][4][2] = F  P[0][4][3] = F  P[0][4][4] = T  P[0][4][5] = F
P[0][5][0] = T  P[0][5][1] = F  P[0][5][2] = F  P[0][5][3] = T  P[0][5][4] = T  P[0][5][5] = T
P[1][0][0] = F  P[1][0][1] = F  P[1][0][2] = F  P[1][0][3] = F  P[1][0][4] = F  P[1][0][5] = F
P[1][1][0] = F  P[1][1][1] = T  P[1][1][2] = F  P[1][1][3] = F  P[1][1][4] = F  P[1][1][5] = F
P[1][2][0] = F  P[1][2][1] = T  P[1][2][2] = T  P[1][2][3] = F  P[1][2][4] = F  P[1][2][5] = F
P[1][3][0] = F  P[1][3][1] = T  P[1][3][2] = T  P[1][3][3] = T  P[1][3][4] = F  P[1][3][5] = F
P[1][4][0] = F  P[1][4][1] = F  P[1][4][2] = F  P[1][4][3] = F  P[1][4][4] = F  P[1][4][5] = F
P[1][5][0] = F  P[1][5][1] = T  P[1][5][2] = T  P[1][5][3] = T  P[1][5][4] = F  P[1][5][5] = T
P[2][0][0] = F  P[2][0][1] = F  P[2][0][2] = F  P[2][0][3] = F  P[2][0][4] = F  P[2][0][5] = F
P[2][1][0] = F  P[2][1][1] = F  P[2][1][2] = F  P[2][1][3] = F  P[2][1][4] = F  P[2][1][5] = F
P[2][2][0] = F  P[2][2][1] = F  P[2][2][2] = T  P[2][2][3] = F  P[2][2][4] = F  P[2][2][5] = F
P[2][3][0] = F  P[2][3][1] = F  P[2][3][2] = T  P[2][3][3] = T  P[2][3][4] = F  P[2][3][5] = F
P[2][4][0] = F  P[2][4][1] = F  P[2][4][2] = F  P[2][4][3] = F  P[2][4][4] = F  P[2][4][5] = F
P[2][5][0] = F  P[2][5][1] = F  P[2][5][2] = T  P[2][5][3] = T  P[2][5][4] = F  P[2][5][5] = T
P[3][0][0] = F  P[3][0][1] = F  P[3][0][2] = F  P[3][0][3] = F  P[3][0][4] = F  P[3][0][5] = F
P[3][1][0] = F  P[3][1][1] = F  P[3][1][2] = F  P[3][1][3] = F  P[3][1][4] = F  P[3][1][5] = F
P[3][2][0] = F  P[3][2][1] = F  P[3][2][2] = F  P[3][2][3] = F  P[3][2][4] = F  P[3][2][5] = F
P[3][3][0] = F  P[3][3][1] = F  P[3][3][2] = F  P[3][3][3] = T  P[3][3][4] = F  P[3][3][5] = F
P[3][4][0] = F  P[3][4][1] = F  P[3][4][2] = F  P[3][4][3] = F  P[3][4][4] = F  P[3][4][5] = F
P[3][5][0] = F  P[3][5][1] = F  P[3][5][2] = F  P[3][5][3] = T  P[3][5][4] = F  P[3][5][5] = T
P[4][0][0] = F  P[4][0][1] = F  P[4][0][2] = F  P[4][0][3] = F  P[4][0][4] = F  P[4][0][5] = F
P[4][1][0] = F  P[4][1][1] = F  P[4][1][2] = F  P[4][1][3] = F  P[4][1][4] = F  P[4][1][5] = F
P[4][2][0] = F  P[4][2][1] = F  P[4][2][2] = F  P[4][2][3] = F  P[4][2][4] = F  P[4][2][5] = F
P[4][3][0] = F  P[4][3][1] = F  P[4][3][2] = F  P[4][3][3] = T  P[4][3][4] = T  P[4][3][5] = F
P[4][4][0] = F  P[4][4][1] = F  P[4][4][2] = F  P[4][4][3] = F  P[4][4][4] = T  P[4][4][5] = F
P[4][5][0] = F  P[4][5][1] = F  P[4][5][2] = F  P[4][5][3] = T  P[4][5][4] = T  P[4][5][5] = T
P[5][0][0] = F  P[5][0][1] = F  P[5][0][2] = F  P[5][0][3] = F  P[5][0][4] = F  P[5][0][5] = F
P[5][1][0] = F  P[5][1][1] = F  P[5][1][2] = F  P[5][1][3] = F  P[5][1][4] = F  P[5][1][5] = F
P[5][2][0] = F  P[5][2][1] = F  P[5][2][2] = F  P[5][2][3] = F  P[5][2][4] = F  P[5][2][5] = F
P[5][3][0] = F  P[5][3][1] = F  P[5][3][2] = F  P[5][3][3] = F  P[5][3][4] = F  P[5][3][5] = F
P[5][4][0] = F  P[5][4][1] = F  P[5][4][2] = F  P[5][4][3] = F  P[5][4][4] = F  P[5][4][5] = F
P[5][5][0] = F  P[5][5][1] = F  P[5][5][2] = F  P[5][5][3] = F  P[5][5][4] = F  P[5][5][5] = T

->测试销毁图： 成功！
演示结束，程序退出！

--------------------------------
Process exited with return value 0
Press any key to continue . . .

*/
